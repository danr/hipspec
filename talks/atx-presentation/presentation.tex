%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\documentclass[serif,professionalfont]{beamer}
\def\maindocument{} % To tell tikz images that they are not stand alone

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,calc}

% \usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
%\usepackage{fixltx2e}
%\usepackage{graphicx}
%\usepackage{longtable}
%\usepackage{float}
%\usepackage{wrapfig}
%\usepackage{soul}
%
%\usepackage{textcomp}
%\usepackage{marvosym}
%\usepackage{wasysym}
%\usepackage{latexsym}
\usepackage{amssymb}

\usepackage{hyperref}

\usepackage{mathpartir}
\usepackage{color}
%\tolerance=1000
\usepackage{inconsolata}
\usepackage{amsmath}
\usepackage{array}
\providecommand{\alert}[1]{\textbf{#1}}

\definecolor{Purpleee}{RGB}{140,20,140}
\definecolor{PurpleL}{RGB}{255,170,255}
\definecolor{MyGreen}{RGB}{5,95,5}
\setbeamercolor{title}{fg=Purpleee}
\setbeamercolor{frametitle}{fg=Purpleee}
\setbeamercolor{structure}{fg=Purpleee}


\TeXXeTstate=1
\usepackage{mathspec,xltxtra,xunicode}
% \setsansfont{Gill Sans}

\setmainfont[Scale=1]{Gill Sans}
%\setmonofont[Scale=0.8]{Monaco}
\setmonofont{Inconsolata}

\setmathsfont(Digits,Latin,Greek){Gill Sans}

\usefonttheme[onlymath]{serif}

%\usepackage{fontspec}
%\defaultfontfeatures{Mapping=tex-text}
%\setsansfont[Ligatures={Common}]{Futura}


\usepackage{listings}

\lstnewenvironment{codex}[1][]%
  {
   \noindent
   \minipage{\linewidth}
   \vspace{0.2\baselineskip}
%   \vspace{-0.4\baselineskip}
   \lstset{basicstyle=\ttfamily,
%           frame=single,
           language=Haskell,
           keywordstyle=\color{black},
           #1}}
  {%\vspace{-0.8\baselineskip}
   \endminipage}

\title{ {\Huge HipSpec} }
\subtitle{ {\LARGE Automating Inductive Proofs \\ of Program Properties} }
\institute{ Chalmers University of Technology | University of Gothenburg }

\author{ {\Large Dan Ros\'en}
     \vspace{\baselineskip} \\
     Koen Claessen, Moa Johansson, Nicholas Smallbone }
\date{July 1, 2012}

\newcommand\fa[1]{ \forall \, #1 . \,}
\newcommand\faa[2]{ \forall \, #1 , #2 . \,}
\newcommand\faaa[3]{ \forall \, #1 , #2 , #3 . \,}
\newcommand\faaaa[4]{ \forall \, #1 , #2 , #3 , #4 . \,}
\newcommand\up[0]{\vspace{-\baselineskip}}
\newcommand\dn[0]{\vspace{\baselineskip}}
\newcommand\hs[1]{\texttt{#1}}

\newcommand\x[0]{\hs{x}}
\newcommand\xs[0]{\hs{xs}}
\newcommand\ys[0]{\hs{ys}}
\newcommand\xxs[0]{\hs{x:xs}}
\newcommand\nil[0]{\hs{[]}}
\newcommand\p[1]{\textsf{P}(#1)}

\newcommand{\highlight}[1]{\colorbox{PurpleL}{\ensuremath{#1}}}

\begin{document}

\maketitle

\begin{frame}[fragile]
  \frametitle{What is HipSpec?}
\tikzstyle{block} = [rectangle, draw=Purpleee, thick, text width=4.75em, text centered]


\makebox[\textwidth][c]{
\begin{tikzpicture}

  \node at (0,0) [block,text width=120] (src) {
\\
\textbf{Haskell source}
{\small
\begin{align*}
&\hs{rev [] = []} \\
&\hs{rev (x:xs)} \\
&\quad\hs{= rev xs ++ [x]} \\ \\
&\hs{prop\_rev xs} \\
&\quad\hs{= rev (rev xs) =:= xs}
\end{align*}
}
};
\pause
  \node at (5,2) [block,text width=120] (hip) {
\textbf{Hip}
\\
\emph{Haskell Inductive Prover}
\begin{itemize}
\item FOL translation
\item Apply induction
\item Success\pause, or stuck!
\end{itemize}
};
\invisible<1-3>{
  \node at (5,-2)  [block,text width=120] (qs) {
\textbf{QuickSpec}
\\
Eq-theory from testing:
\vspace{-0.5\baselineskip}
{\small
\begin{align*}
&\hs{rev (xs ++ ys)} \\
&\quad\hs{= rev ys ++ rev xs} \\
&\hs{xs ++ [] = []} \\
&\hs{xs ++ (ys ++ zs) =} \\
&\quad\hs{(xs ++ ys) ++ zs}
\end{align*}
}};

  \onslide<5>{
    \node at (8.5,-2) [block] (lemmas)
       {\textbf{HipSpec} \\ \emph{Use these as lemmas!!}};
  }

\end{tikzpicture}
}
}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Example functional program and property}
  %\begin{center}

    \begin{verbatim}
        rev (x:xs) = rev xs ++ [x]
        rev []     = []

        qrev (x:xs) ys = qrev xs (x:ys)
        qrev []     ys = ys
    \end{verbatim}

    \begin{equation*}
    \text{Goal:} \quad \fa{\xs} \hs{rev xs} = \hs{qrev xs []}
    \end{equation*}

%    \pause
%
%       \begin{align*}
%         \text{lhs:} \quad & \hs{rev xs} = ... \\
%         \text{rhs:} \quad & \hs{qrev xs []} = ...
%       \end{align*}
%
%    \pause
%
%    \begin{center}
%      {\color{red} Stuck!}
%    \end{center}

\end{frame}

%   \begin{align*}
%     & \text{to show: } && \hs{rev (x:xs)} = \hs{qrev (x:xs) []} \\
%     \\
%     & \text{lhs:}      && \hs{rev (x:xs)} = \hs{rev xs ++ [x]} \\
%     &                  && = \hs{qrev xs [] ++ [x]} \\
%     & \text{rhs: }     && \hs{qrev (x:xs) []} = \hs{qrev xs [x]}
%   \end{align*}

%\begin{frame}[fragile]
%  \frametitle{Case split}
%
%  In a well-typed language, any list such as $\xs$ is either nil or cons!
%      \begin{mathpar}
%        \inferrule*
%           {
%             \p{\nil}
%             \\
%             \faa{\x}{\xs} \p{\xxs}
%           }
%           { \fa{\xs} \p{\xs} }
%      \end{mathpar}
%
%  \pause
%
%  \begin{equation*}
%   \p{\xs} \Leftrightarrow \hs{rev xs} = \hs{qrev xs []}
%  \end{equation*}
%
%  \invisible<1-2>{
%  \only<1-3>{
%
%     Nil case:
%
%     \begin{align*}
%       \text{lhs:} \quad & \hs{rev []} = \nil  \\
%       \text{rhs:} \quad & \hs{qrev [] []} = \nil
%     \end{align*}
%
%     \pause
%     \begin{center}{\color{MyGreen} Hooray!}\end{center}
%  }
%  \only<4-5>{
%     Cons case:
%
%     \begin{align*}
%       \text{lhs:} \quad & \hs{rev (x:xs)} = \hs{rev xs ++ [x]} \\
%       \text{rhs:} \quad & \hs{qrev (x:xs) []} = \hs{qrev xs [x]}
%     \end{align*}
%
%     \onslide<5>{\begin{center}{\color{red} Stuck!!!}\end{center}}
%  }
%  }
%\end{frame}

\begin{frame}[fragile]
  \frametitle{Structural induction}

  \begin{mathpar}
    \inferrule*
       {
         \p{\nil}
         \\
         \faa{\x}{\xs} \p{\xs} \implies \p{\xxs}
       }
       { \fa{\xs} \p{\xs} }
  \end{mathpar}

  \pause

  \begin{align*}
    \text{lhs:} \quad & \hs{rev (x:xs)} = \hs{rev xs ++ [x]} \onslide<4->{\highlight{ = \hs{qrev xs [] ++ [x]}}} \\
    \text{rhs:} \quad & \hs{qrev (x:xs) []} = \hs{qrev xs [x]}
  \end{align*}

  \pause

  \begin{equation*}
  \textsf{hypothesis:} \quad \hs{rev xs} = \hs{qrev xs []}
  \end{equation*}

  \pause
  \pause
  \begin{center}{\color{red} \Large Stuck!!!}\end{center}

\end{frame}
\begin{frame}[fragile]
  \frametitle{How do we proceed?}

    \begin{verbatim}
        rev (x:xs) = rev xs ++ [x]
        rev []     = []

        qrev (x:xs) ys = qrev xs (x:ys)
        qrev []     ys = ys
    \end{verbatim}

  \up\up

  \begin{align*}
    \text{lhs:} \quad & \hs{rev (x:xs)} = \hs{rev xs ++ [x]}  = \hs{qrev xs [] ++ [x]} \\
    \text{rhs:} \quad & \hs{qrev (x:xs) []} = \hs{qrev xs [x]}
  \end{align*}

  \pause

  What about...
  \begin{equation*}
    \textsf{New Goal:} \quad \faa{\xs}{\highlight{\ys}} \hs{rev xs}\highlight{\hs{ ++ ys}} = \hs{qrev xs }\highlight{\ys}
  \end{equation*}

  \pause

  Then with $\ys = \nil$, we get
  \begin{equation*}
    \onslide<4>{\hs{rev xs} = }\hs{rev xs ++ []} = \hs{qrev xs []}
  \end{equation*}

\end{frame}


\begin{frame}[fragile]
  \frametitle{The crucial lemma}

  \begin{equation*}
  \textsf{New Goal:} \quad \faa{\xs}{\ys} \hs{rev xs ++ ys} = \hs{qrev xs ys}
  \end{equation*}


  \vspace{\baselineskip}

  Induction on $\xs$

  \dn \pause

  Base, to show: $\fa{\ys} \hs{rev [] ++ ys} = \hs{qrev xs []}$

  \begin{align*}
    \text{lhs:} \quad & \hs{rev [] ++ ys} = \ys  \\
    \text{rhs:} \quad & \hs{qrev [] ys} = \ys
  \end{align*}

   \pause

  {\begin{center}{\color{MyGreen} Hooray!}\end{center}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The crucial lemma}
  Step, to show: $\fa{\ys} \hs{rev (x:xs) ++ ys} = \hs{qrev (x:xs) ys}$

  \dn

  Hypothesis: $\fa{\ys} \hs{rev xs ++ ys} = \hs{qrev xs ys}$

  \pause

  \begin{align*}
  \text{lhs } = \;\; & \hs{rev (x:xs) ++ ys}      && =\{\text{definition of \hs{rev}}\} \\
                     & \hs{(rev xs ++ [x]) ++ ys} && =\{\text{associativity of \hs{++}}\} \\
                     & \hs{rev xs ++ ([x] ++ ys)} && =\{\text{definition of \hs{++}}\} \\
                     & \hs{rev xs ++ (x:ys)}      && =\{\text{induction hypothesis on $\hs{(x:ys)}$}\} \\
                     & \hs{qrev xs (x:ys)}        && =\{\text{definition of \hs{qrev}}\} \\
                     & \hs{qrev (x:xs) ys}        && = \text{rhs}
  \end{align*}

  \pause
  {\begin{center}{\color{MyGreen} \Large HOORAY!}\end{center}}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Success}

     We managed to prove

     \begin{equation*}
     \fa{\xs} \hs{rev xs} = \hs{qrev xs []}
     \end{equation*}

     Using:

     \begin{itemize}
       \item $\faa{\xs}{\ys} \hs{rev xs ++ ys} = \hs{qrev xs ys}$
       \item Induction
         \pause
       \item But we also needed associativity of \hs{++} and $\fa{\xs} \hs{xs ++ []} = \xs$,
             which need induction to be proved
     \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Setting}

  Prove properties of functional programs using rewriting and
  induction.

  \dn

  {\color{Purpleee} Problem:} Some of these properties require lemmas, that

  \begin{itemize}
    \item Needs to be conjectured,
    \item Requires induction to be proved, and
    \item Might require lemmas themselves
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Enter HipSpec}

  Solves this problems by:

  \begin{itemize}
    \item Generates an equational theory by counter-example testing,
    \item Try to prove this theory by applying induction
    \item Then, try to prove the user-stated properties
    \item Proof search with first-order theorem provers
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Overview of HipSpec}
  \input{hipspec-picture}
\end{frame}

\begin{frame}
  \frametitle{Overview of HipSpec}
  \def\hlqs{} % Highlight QuickSpec
  \input{hipspec-picture}
  \undef\hlqs
\end{frame}

\newcommand\vb[1]{\mbox{{\tt #1}}}

\tikzstyle{eqblock} = [rectangle, draw=Purpleee, thick, text width=4.75em]

\begin{frame}[fragile]
\frametitle{Equivalence classes partitioning}

Generates a bunch of terms:

\dn


\begin{tabular}{>{\footnotesize}l >{\footnotesize}l >{\footnotesize}l >{\footnotesize}l}
\vb{[]}&
\vb{[]++[]}&
\vb{qrev [] []}&
\vb{qrev (rev xs) []}\\
\vb{qrev [] (rev xs)}&
\vb{qrev (rev xs) ys}&
\vb{qrev [] xs}&
\vb{qrev xs []}\\
\vb{[]++qrev xs ys}&
\vb{qrev [] (xs++ys)}&
\vb{(x:xs)++[]}&
\vb{qrev xs ys++[]}\\
\vb{qrev (x:[]) xs}&
\vb{qrev [] (x:xs)}&
\vb{rev []}&
\vb{rev (qrev ys xs)}\\
\vb{rev (rev xs)}&
\vb{[]++rev xs}&
\vb{rev xs}&
\vb{rev xs++ys}\\
\vb{xs}&
\vb{[]++xs}&
\vb{xs++[]}&
\vb{(xs++ys)++[]}\\
\vb{[]++(xs++ys)}&
\vb{xs++ys}&
\vb{(x:[])++xs}&
\vb{xs++(x:[])}
\end{tabular}

\end{frame}

\begin{frame}[fragile]
\frametitle{Equivalence classes partitioning}

\makebox[\textwidth][c]{
\begin{tikzpicture}

\node at (0,2) [eqblock,text width=90] (src) {
\vb{xs}\\
\vb{xs++[]}\\
\vb{[]++xs}\\
\vb{qrev [] xs}\\
\vb{rev (rev xs)}\\
\vb{qrev (rev xs) []}\\
};


\node at (0,-2) [eqblock,text width=90] {
\vb{xs++ys}\\
\vb{qrev (rev xs) ys}\\
\vb{[]++(xs++ys)}\\
\vb{qrev [] (xs++ys)}\\
\vb{(xs++ys)++[]}\\
};

\node at (4,2) [eqblock,text width=60] {
\vb{[]}\\
\vb{rev []}\\
\vb{qrev [] []}\\
\vb{[]++[]}\\
};

\node at (4,-2)  [eqblock,text width=80] {
\vb{x:xs}\\
\vb{[]++(x:xs)}\\
\vb{qrev [] (x:xs)}\\
\vb{(x:xs)++[]}\\
\vb{(x:[])++xs}\\
\vb{qrev (x:[]) xs}\\
};

\node at (8,2)  [eqblock,text width=120] {
\vb{qrev xs ys}\\
\vb{rev (qrev ys xs)}\\
\vb{rev xs++ys}\\
\vb{[]++qrev xs ys}\\
\vb{qrev [] (qrev xs ys)}\\
\vb{qrev xs ys++[]}\\
\vb{qrev (qrev ys xs) []}\\

};

\node at (8,-2)  [eqblock,text width=100] {
\vb{rev xs}\\
\vb{qrev xs []}\\
\vb{[]++rev xs}\\
\vb{qrev [] (rev xs)}\\
};

\end{tikzpicture}
}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Example of pruned equations from QuickSpec}

\begin{verbatim}
Universe has 2893 terms, 1824 classes
== equations ==
 1: xs++[] == xs
 2: qrev xs [] == rev xs
 3: []++xs == xs
 4: qrev [] xs == xs
 5: (x:xs)++ys == x:(xs++ys)
 6: (xs++ys)++zs == xs++(ys++zs)
 7: qrev xs ys++zs == qrev xs (ys++zs)
 8: qrev (x:xs) ys == qrev xs (x:ys)
 9: qrev (xs++ys) zs == qrev ys (qrev xs zs)
10: qrev (qrev xs ys) zs == qrev ys (xs++zs)
\end{verbatim}

\end{frame}

\begin{frame}
  \frametitle{Overview of HipSpec}
  \def\hltrans{} % Highlight translation
  \input{hipspec-picture}
  \undef\hltrans
\end{frame}

\newcommand\fn[1]{\mathrm{#1}}
\newcommand\fcons   [2]{\fn{cons}(#1,#2)}
\newcommand\frev    [1]{\fn{rev}(#1)}
\newcommand\fxs     [0]{\textsf{xs}}
\newcommand\fx      [0]{\textsf{x}}
\newcommand\fys     [0]{\textsf{ys}}
\newcommand\fy      [0]{\textsf{y}}
\newcommand\fappend [2]{\fn{append}(#1,#2)}
\newcommand\fnil    [0]{\fn{nil}}

\begin{frame}[fragile]
  \frametitle{Hip : The Haskell Inductive Prover}

  \begin{itemize}
    \item Translates the Haskell source definitions to first order logic
\up
  \end{itemize}
  \begin{verbatim}
      rev (x:xs) = rev xs ++ [x]
      rev []     = []
  \end{verbatim}
\up
Function definition axioms:
\begin{align*}
1 && \faa{\fx}{\fxs} & \frev{\fcons{\fx}{\fxs}} = \fappend{\frev{\fxs}}{\fcons{\fx}{\fnil}} \\
2 &&                 & \frev{\fnil}             = \fnil
\end{align*}
Data type axioms:
\begin{align*}
3 && \faaaa{\fx}{\fxs}{\fy}{\fys} & \fcons{\fx}{\fxs} = \fcons{\fy}{\fys} \implies \fx = \fy \land \fxs = \fys \\
4 && \faa{\fx}{\fxs} & \fnil \neq \fcons{\fx}{\fxs}
\end{align*}
\up
  \begin{itemize}
  \item Also supports higher-order functions and partial application
  \item Applies structural induction on properties
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Picking a conjecture, and the main loop}

  \def\onlyloop{}
  \input{hipspec-picture}
  \undef\onlyloop

  \begin{enumerate}
    \item Try to prove ``smallest'' unproved equation this round
    \item Failure: save this for next round
    \item Success: extend the theory
    \item When a round did not lead to any successes, or everything proved, terminate.
  \end{enumerate}

  \pause

  We use light-weight reasoning by means of a congruence closure to
  prune away conjecture that can be proved without induction. % equations from QuickSpec holding up to equality.

\end{frame}

\begin{frame}
  \frametitle{}
    \begin{center}
    {\color{Purpleee} \Huge Demo!}
    \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation - First Test Suite}

  First suite from
  \emph{Case-Analysis for Rippling and Inductive Proof}
  \hspace{1em} by Johansson, Dixon and Bundy (2010)

  \dn

  85 conjectures, 71 equational.

  \pause

  \begin{center}
  \begin{tabular}{l l}
    Tool       & Proved conjectures (of 85) \\
    \hline
    Zeno       & 82 \\[3pt]
    ACL2s      & 74 \\[3pt]
    IsaPlanner & 47 \\[3pt]
    Dafny      & 45 \\[3pt]
    HipSpec    & 67 (of 71)
  \end{tabular}
  \end{center}

  \pause

  \invisible<1-2>{
     %Buggy!? wtf latex
     \only<1-3>{
       Unproved:
       \up
       \begin{center}
       \begin{tabular}{>{\small}l >{\small}l}
       \hs{count n xs = count n (sort xs)}, & \hs{len (filter p xs) <= len xs } \\
       \hs{sorted (sort xs) = True},        & \hs{len (delete n xs) <= len xs }
       \end{tabular}
       \end{center}
       But they require conditional lemmas!
     }
     \only<4>{
       Two properties only proved by HipSpec!
       \begin{center}
       \begin{tabular}{>{\small}l}
       \hs{rev (drop i xs) = take (len xs - i) (rev xs)} \\
       \hs{rev (take i xs) = drop (len xs - i) (rev xs)}
       \end{tabular}
       \end{center}
       Requires a bunch of quite far-fetched lemmas
     }
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation - Second Test Suite}

  Second test suite from
      \emph{Productive Use of Failure in Inductive Proof}
      \hspace{1em} by Bundy and Ireland (1995)

  \dn

  Their tool CLAM supposedly proves all, but some properties contrived
  towards their tool, cf \hs{rev (rev xs ++ []) = xs}

  \dn

  49 theorems, 38 equational. \pause HipSpec proves 36!

  \pause
  \dn

  Unproved:
  \begin{center}
  \begin{tabular}{>{\small}c >{\small}l}
  No  & Conjecture \\
  \hline
  T14 & \verb!ordered (isort xs) = True! \\
  T50 & \verb!count x (isort xs) = count x xs! \\
  \end{tabular}
  \end{center}

  \dn

  Zeno? \pause Proves 21/49

\end{frame}

\begin{frame}
  \frametitle{}
    \begin{center}
    {\color{Purpleee} \Huge Success!\pause?}

    \vspace{\baselineskip}

    There might be some limitations... ;)
    \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Future work and current limitations}

  \begin{itemize}
    \item Better heuristics (Equation order)
    \item Big theories and scalability
    \item Conditional properties
    \item Non-terminating programs and infinite values
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Conclusion}

  Exploring the laws that hold through testing does not only help your
  understanding, but also helps to prove properties.

  \dn

  A form of completeness from QuickSpec: If there are laws up to a
  certain term size then QuickSpec is guaranteed to find them.

  \dn

  \emph{If the lemma is there, HipSpec will eventually try to prove it!}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Extra slides}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Obtaining HipSpec}

  \begin{itemize}

    \item Clone the repository:
      \\ \hs{git clone http://github.com/danr/hipspec}

    \item Installation (requires GHC):
       \\ \hs{cd hipspec}
       \\ \hs{git submodule update --init}
       \\ \hs{cabal install}

    \item Install a theorem prover (say eprover)

    \item Try an example!
       \\ \hs{cd testsuite/}
       \\ \hs{runghc Reverse.hs}

  \end{itemize}

  % These slides:
  % \hs{http://web.student.chalmers.se/\溽铗栝痼疱悱箪殇弩痄纨苠钿骝犴妪茆彗轭骝犴妪坻蜥玳戾苕蜥礤糸綮妍契趱蝈黠螂麻翳屣蜷弩葬腴铉犰秕骢钽糸镱骝镯忾痱镧蜥砗茆彗轭轸屙辁妪荛翦藻篝轭翎脲祜铉糸礤荛翦体眄狍忮泔礤躅蝈灬翦苠钿轸屙辁妪莛狨箦荟箴徙妍茆狍屐轭弩腴瘕蕊滹麇腩秣麒孱骢钽糸镱狎蝈灬翦淇茆彗轭羼踽糸镱荑篼戾铉翳螬荑篼戾铉翳螬苠钿羼踽糸镱苠钿骝犴妪茆彗轭骝犴妪坻蜥玳戾苕蜥礤糸綮妍契趱蝈黠螂蔑钿轸轱钺痱镳弪糸弩体眄狍鏖翳轫痨殂狒轱铙茆彗轭羼踽糸镱荑篼箫螋邃簖荑篼则蹂荛眇扉弩荑篼箫螋邃ㄩ铙弪螬荑篼则蹂苠钿羼踽糸镱莛狨箦茔镬矧絮蝠戾邋趄殂牒躞铄溽翎豉疱徕篝蜥泗骘乳鹩疱愫茆彗轭鲥蜮狒轫溽翎语螋邃涕篝语螋邃涕篝珏粲矧翦涮轶汉畚狒轭篝犷沐硫忾翎蝙语螋邃涕篝麒弪狎忾趄狎语螋邃涕篝筱犷毂ǐ噫磲疣狎忾趄狎苠钿鲥蜮狒轫荟箴徙妍茆狍屐轭弩腴瘕莛狨箦物鳜麇汜篝狒翳痱镳弪豉轭翦蝽镦箫螋邃扉篝荑篼箪茆彗轭羼踽糸镱荑篼箫螋邃ㄩ铙弪ㄧ弭语螋邃涕篝箪┅荑篼则蹂苠钿羼踽糸镱五邃铒翎糸镱麸乳鹩疱翳狒荑篼语螋邃涕篝栳荑篼箫螋邃轭鲠蜷犷舢苠钿骝犴妪茆彗轭骝犴妪坻蜥玳戾苕蜥礤糸綮妍义灬翦黠螂茔镬矧蝈潺轭泔眇戾翦箪殇妪茆彗轭轸屙辁妪荛翦御铘徙糸轭漉泗轹狃痱镝汨弩蜷痧扉铉荛翦审崦矬荛翦阱铒苠钿轸屙辁妪苠钿骝犴妪茆彗轭骝犴妪坻蜥玳戾苕蜥礤糸綮妍序镲婧芴狎珏荇屮趑酐蝈ㄤ蝻螬翎脲戾蟓椹蝈螬茆彗轭沐铘弪茆彗轭翎怩灬螨钧荏磲祆钧荏磲祆忑物蔑铌邈趱蝈苘荑扉铄荟弪狻戾ㄤ蝻螬戾蟓苘郗别糨荟弪狻戾戾蝈螬苘郗别糨荟弪狻翎脲螳潋镳蟆苘郗别糨荟弪狻蝈螳螬蝈螳蝈蟆苘郗别糨荟弪狻翎脲戾螬螳螬苠钿翎怩灬螨苠钿沐铘弪茆彗轭犰殓瞠荑箴徙妍插睚荏磲祆荑篼蝈ㄤ蝻螬荏磲祆莒彐糗茯殓梏荦苘郗仇糨荑箴徙妍插睚荏磲祆荑篼翎脲戾蝈ㄤ蝻螬┅蝈ㄤ蝻螬蝈翎脲螬荏磲祆莒彐糗茯殓梏荦苘郗仇糨荑箴徙妍插睚荏磲祆荑篼翎脲戾ㄤ蝻螬蝈ㄤ蝻螬蝈翎脲螬荏磲祆莒彐糗茯殓梏荦苘郗仇糨荑箴徙妍插睚荏磲祆荑篼翎脲戾蟓椹蝈ㄤ蝻螬蝈翎脲螬荏磲祆莒彐糗茯殓梏荦苘郗仇糨荑箴徙妍插睚荏磲祆荑篼翎脲戾蟓椹蝈翎脲螳潋镳螬荏磲祆莒彐糗茯殓梏荦苘郗仇糨荑箴徙妍插睚荏磲祆荑篼翎脲戾蟓椹蝈螬苠钿犰殓瞠苠钿骝犴妪茆彗轭骝犴妪坻蜥玳戾苕蜥礤糸綮妍契趱蝈黠螂蔑钿轸轱钺痱镳弪糸弩缮阻狒徕秕茆彗轭羼踽糸镱荑篼荑篼则蹂莒犷荑篼荑篼则蹂荛眇扉弩荑篼荑篼则蹂苠钿羼踽糸镱莛狨箦俞礤趄殂肟茆彗轭鲥蜮狒轫溽翎嗅轵嗅轵箜犰戾汉吾灬蜱弪汉吾苠钿鲥蜮狒轫冕麇篝狒翳痱镳弪豉茆彗轭羼踽糸镱荑篼箜犰戾鸨灬蜱弪鸩荑篼则蹂苠钿羼踽糸镱莛狨箦茔镬矧蝈潺序镡戾砗栾狎荑篼鸨犷荑篼鸩蝈灬翦淇苠钿骝犴妪茆彗轭骝犴妪坻蜥玳戾苕蜥礤糸綮妍涕黹翎糸镱砒疱铙轹汜煦蹯狒轱铙身徵轭痱镧蜥麒殂滹弩屮痫铄铘獒糸镱荑篼镱躅狎钺趔荑篼溽翎吾阱蝻吁沣吾酏荟箴徙妍茆狍屐轭弩腴瘕燥屮疱铙轹麸汜祯沆狒荑篼荟箴徙妍茆狍屐轭弩腴瘕莛狨箦茆彗轭鲥蜮狒轫殒浇卑鞍鞍鞍鞍鞍翳孱屐箦苠钿鲥蜮狒轫苠钿骝犴妪ゥゥゥ茆彗轭骝犴妪ゥ苕蜥礤糸綮妍洛栝钿翳鱼孱弩ゥ茆彗轭轸屙辁妪ゥ荛翦则犷箪狒轱麸骈蝮矧溴祜玳丬ゥ荛翦则轭溟骀弪孱轭漉泗轱翦汨铋聃弩苘ゥ荛翦阴铑轭狨麸磲翦翳屣蝈痱秭弪筌ゥ苠钿轸屙辁妪ゥ苠钿骝犴妪ゥゥゥ茆彗轭骝犴妪坻蜥玳戾ゥ苕蜥礤糸綮妍郁蝓泗躜犰深漉泗轱砒犴痨妪ゥゥ茆彗轭磲翳疳螨ゥ荛铈弪蝓戾ゥゥ楔莒遽纣ゥ茚钿ゥ楔酴荀邃珏楔雯茯殓梏狎蝻楔苕矧臌觚鳊ゥゥ楔舂ゥ苠钿磲翳疳螨ゥゥゥ茆彗轭骝犴妪坻蜥玳戾ゥ苕蜥礤糸綮妍契趱蝈罪螂体眄簌铘桢箝骝镯氧殂胗疱泯ゥゥ茆彗轭鲥蜮狒轫ゥ焙蝈趱蝾航痕ゥ埠壶航蝈趱蝾ゥ浇羼踽糸镱浇ゥ焙痕浇蝈趱蝾ゥ埠螳圯浇ゥ澈圯浇ゥ春蝈鲥蝮圯浇圯ゥ岛壶螬浇酣螳螬ゥ逗螳螬浇螳螳螬ゥ泛蝈鲥蝮蝈趱蝾浇蝈趱蝾ゥ负蝈鲥蝮蝈鲥蝮螬浇ゥ购蝈鲥蝮螳蝈趱蝾浇蝈鲥蝮壶螬ゥ卑蝈鲥蝮螳蝈鲥蝮浇蝈鲥蝮螳螬ゥ苠钿鲥蜮狒轫ゥ苠钿骝犴妪ゥゥゥ拖峙韵盼ゥ茆彗轭骝犴妪ゥ苕蜥礤糸綮妍义灬翦罪螂ゥ茆彗轭轸屙辁妪ゥ荛翦阱铒ㄓ镱铄尿矬箫痫蹯秕砰箦钼徙瑭苕镲纛雉弩辁濞身疱蜷犰蔑祆彗濠ゥゥ荛翦蔑礅轭轭深翦蜥泗轹犷刘麸磲糸义狍镱轭徕秕契钽糸镱犰序镧蜥眢苘ゥ嘛鲥涅怅弪娱汜蜾ゥ荛翦腻疱钿孱綮赠疱序镧蜥眄轭忉箦镱刘麸磲翦澡屣蝈序秭轭苘ゥ硫眢趄镱绗骑篝弪郁蝓翳苕镲纛雉弩辁濞疹轹镦予彐骈屐洎ゥ苠钿轸屙辁妪ゥ苠钿骝犴妪ゥゥ茆彗轭骝犴妪ゥ苕蜥礤糸綮妍蔑钽祯箝镱ゥゥ茆彗轭轸屙辁妪ゥ荛翦葡轶屮痱弩箝忪孱秕玷骘鲠蜷秕柔箅屐泔钽屦趔疳趑弪ゥ磲翥栝铉轭骈铋翦溽翎篝蝓泗躜弩犷栝玷弪矧溴骢钽糸镱ゥ荛翦澡犷塍麸蝈驽蝈铘獒趄犷箴狎孱泫ゥ荛翦酗篌殁戾麸痱秭磲铢痱镳弪糸弩鏖翳秕痱秭轭翦蝽轭狒轱ゥ苠钿轸屙辁妪ゥ苠钿骝犴妪ゥゥゥゥ响磲泸矬ゥ茼犭遽綮弭翦ゥ茴鬻泔眄犷洫茯镯郾蓰荇屮酐苕镲纛雉弩辁遘屮疳钿徭翦蜍荔祜黩镯犷汜疖蝻磲铑蹴弪犰１喇ゥ茴鬻泔眄犷洫茯镯铒滹酏郾蓰荇屮酐苕镲纛雉弩辁遘屮疳钿徭翦蜍荔祜黩镯犷汜疖蝻磲铑蹴弪犰１例ゥ茼犭遽麸翳弪ゥ茴鬻泔眄犷滠铒翦郾蓰茼怙茼狎玳铕狎苕镲纛雉弩辁遘蜥珑邃蜷玷糗梵疳沐梆酏苠眇棼１ゥ茴鬻泔眄犷滠铒翦郾蓰ゥ茴鬻泔眄犷滠辛茼狒桡犰熊×ゥ茴鬻泔眄犷滠梵郾蓰荟弪恂１
%%\newcommand\ts[1]{\verb#1}
%%\newcommand\fn[1]{#1}
%%\newcommand\ptr[1]{\fn{\operatorname{#1-ptr}}}
%%\newcommand\appfn{@}
%%\newcommand\app[2]{#1 \, \appfn \, #2}
%%\newcommand\appp[2]{(#1) \, \appfn \, #2}
%%\newcommand\ex[1]{\exists \, #1 \, . \,}
%%\newcommand\nexxx[3]{\nexists \, #1 , #2 , #3 . \,}
%%
%%\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}%\usetikzlibrary {\trees,positioning,arrows}
%%
%%\newcommand\fixb[0]{ ^{\bullet}}
%%\newcommand\fixw[0]{ ^{\circ}}
%%
%%\newcommand\tofix[1]{#1^{\bullet}}
%%\newcommand\unfix[1]{#1^{\circ}}
%%
%%\newcommand\append[0]{\texttt{\small{++}}}
%%
%%\newcommand{\xsys}[2]{#1 \, xs \, #2 & = #1 \, ys #2}
%%\newcommand{\desca}[1]{  & \hspace{44.5mm}                            \{ \text{#1} \}}
%%\newcommand{\descra}[1]{ & \hspace{35mm} \Rightarrow     \hspace{4mm} \{ \text{#1} \}}
%%\newcommand{\descla}[1]{ & \hspace{35mm} \Leftarrow      \hspace{4mm} \{ \text{#1} \}}
%%\newcommand{\desclra}[1]{& \hspace{35mm} \Leftrightarrow \hspace{4mm} \{ \text{#1} \}}
%%
%%\newcommand\lub[1]{\sqcup_{#1}}
%%
%%\newcommand\defof[1]{definition of #1}
%%
%%\newcommand\w[0]{\,\,}
%%\newcommand\eq[0]{ = }
%%
%%\newcommand{\defBNF}[4] {\text{#1}\quad&#2&::=&\;#3&\text{#4}}
%%\newcommand{\defaltBNF}[2] {&&|&\;#1&\text{#2}}
%%
%%\newcommand{\hstup}[2]{\hs{(} #1 \hs{,} #2 \hs{)}}
%%
%%\newcommand{\nsqsubseteq}{\,\,\, /\!\!\!\!\!\!\sqsubseteq}
%%
%%\newcommand{\bindname}{>\!\!>\!\!=}
%%\newcommand{\bind}[2]{#1 \bindname #2}
%%\newcommand{\bindp}[3]{\fn{bind'}(#1,#2,#3)}
%%\newcommand{\fork}[2]{\fn{fork}(#1,#2)}
%%\newcommand{\forkr}[1]{\fn{right}(#1)}
%%\newcommand{\forkl}[1]{\fn{left}(#1)}
%%\newcommand{\leaf}[1]{\fn{leaf}(#1)}
%%\newcommand{\unleaf}[1]{\fn{unleaf}(#1)}
%%\newcommand{\return}[1]{\fn{return}(#1)}
%%
%%\newcommand{\bindb}[2]{#1 \tofix{\bindname} #2}
%%\newcommand{\bindw}[2]{#1 \unfix{\bindname} #2}
%%
%%
%%\newcommand\Inf{\fn{Inf}}
%%\newcommand\Total{\fn{Total}}
%%\newcommand\Fin{\fn{Fin}}

\end{document}
